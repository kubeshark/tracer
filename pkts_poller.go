package main

import (
	"fmt"
	"sync"
	"unsafe"

	"github.com/cilium/ebpf/perf"
	"github.com/go-errors/errors"

	"github.com/kubeshark/gopacket"
	"github.com/kubeshark/gopacket/layers"
	"github.com/kubeshark/tracer/misc/ethernet"
	"github.com/rs/zerolog/log"
)

type tracerPktData struct {
	ID   uint64
	Num  uint16
	Len  uint16
	Last uint16
	Data [4096]uint8
}

type tracerPktChunk struct {
	cpu int
	buf []byte
}

type pktBuffer struct {
	id  uint64
	num uint16
	len uint32
	buf [64 * 1024]byte
}

type pktsPoller struct {
	ethhdr       *layers.Ethernet
	mtx          sync.Mutex
	chunksReader *perf.Reader
	sorter       *PacketSorter
	pktsMap      map[int]*pktBuffer // CPU to packet
}

func newPktsPoller(
	tls *Tracer,
	procfs string,
	sorter *PacketSorter,
) (*pktsPoller, error) {
	poller := &pktsPoller{
		ethhdr:  ethernet.NewEthernetLayer(layers.EthernetTypeIPv4),
		sorter:  sorter,
		pktsMap: make(map[int]*pktBuffer),
	}

	return poller, nil
}

func (p *pktsPoller) init(bpfObjects *tracerObjects, bufferSize int) error {
	var err error

	p.chunksReader, err = perf.NewReader(bpfObjects.PktsBuffer, bufferSize)

	if err != nil {
		return errors.Wrap(err, 0)
	}

	return nil
}

func (p *pktsPoller) close() error {
	return p.chunksReader.Close()
}

func (p *pktsPoller) poll() {
	// tracerPktsChunk is generated by bpf2go.
	chunks := make(chan *tracerPktChunk)

	go p.pollChunksPerfBuffer(chunks)

	for chunk := range chunks {
		if err := p.handlePktChunk(chunk); err != nil {
			logError(err)
		}
	}
}

func (p *pktsPoller) handlePktChunk(chunk *tracerPktChunk) error {
	p.mtx.Lock()
	defer p.mtx.Unlock()

	data := chunk.buf
	if len(data) != 4116 {
		return fmt.Errorf("bad pkt chunk: %v", len(data))
	}
	ptr := (*tracerPktData)(unsafe.Pointer(&data[0]))

	pkts, ok := p.pktsMap[chunk.cpu]
	if !ok {
		p.pktsMap[chunk.cpu] = &pktBuffer{}
		pkts = p.pktsMap[chunk.cpu]
	}
	if ptr.Num != pkts.num {
		if ptr.ID == pkts.id {
			return fmt.Errorf("Lost packet message from %v to %v", pkts.id, ptr.ID)
		}
		pkts.len = 0
		pkts.num = 0
		pkts.id = ptr.ID
		if ptr.Num != pkts.num {
			return fmt.Errorf("Lost packet message from %v to %v", pkts.num, ptr.Num)
		}
	}

	copy(pkts.buf[pkts.len:], ptr.Data[:ptr.Len])
	pkts.len += uint32(ptr.Len)
	if ptr.Last != 0 {
		err := p.sorter.WritePlanePacket(layers.LayerTypeEthernet, p.ethhdr, gopacket.Payload(pkts.buf[:pkts.len]))
		if err != nil {
			return err
		}

		pkts.len = 0
		pkts.num = 0
		pkts.id++
	} else {
		pkts.num++
	}

	return nil
}

func (p *pktsPoller) pollChunksPerfBuffer(chunks chan<- *tracerPktChunk) {
	log.Info().Msg("Start polling for tls events")

	for {
		record, err := p.chunksReader.Read()

		if err != nil {
			close(chunks)

			if errors.Is(err, perf.ErrClosed) {
				return
			}

			logError(errors.Errorf("Error reading chunks from pkts perf, aborting! %v", err))
			return
		}
		if record.LostSamples != 0 {
			log.Info().Msg(fmt.Sprintf("Buffer is full, dropped %d pkt chunks", record.LostSamples))
			continue
		}

		chunk := tracerPktChunk{
			cpu: record.CPU,
			buf: record.RawSample,
		}

		chunks <- &chunk

	}
}
